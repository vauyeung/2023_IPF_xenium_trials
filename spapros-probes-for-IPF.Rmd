---
title: "Probe selection for IPF lung using SPAPROS"
output:
  github_document:
    toc: true
  html_notebook:
    toc: true
--- 

# Environment

## load R environment
```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(Seurat)
```

## Load IPF Cell Atlas data
Spapros is expecting scanpy format data with raw counts. Load based on established R workflow then convert.
### Read in GSE136831
```{r}
original.dir <- ('~/vcalab-files/datasets/GSE136831_IPF_Cell_Atlas/')
metadata <- read_tsv(paste0(original.dir,'GSE136831_AllCells.Samples.CellType.MetadataTable.txt.gz'))
metadata <- as.data.frame(metadata)
rownames(metadata) <- metadata$CellBarcode_Identity

features <- read_tsv(paste0(original.dir,'GSE136831_AllCells.GeneIDs.txt.gz'))
cells <- read_tsv(paste0(original.dir,'GSE136831_AllCells.cellBarcodes.txt.gz'), col_names = F)

counts <- Matrix::readMM(paste0(original.dir,'GSE136831_RawCounts_Sparse.mtx.gz'))
rownames(counts) <- features$HGNC_EnsemblAlt_GeneID
colnames(counts) <- cells$X1
```
```{r}
ipfatlas.cells <- CreateSeuratObject(counts=counts, meta.data=metadata)
```
```{r}
rm(counts,cells,features,metadata)
gc()
```
### Standard filters
```{r}
ipfatlas.cells[['percent.mt']] <- PercentageFeatureSet(ipfatlas.cells, pattern='^MT-')
VlnPlot(ipfatlas.cells, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, pt.size = 0)
```
```{r}
ipfatlas.cells <- subset(ipfatlas.cells, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & percent.mt < 10)
```
### Convert to scanpy compatible format (anndata)
This is remarkably not a solved problem but sceasy has functions for it. have to back-convert the Seurat5 object to a v3-like assay.
```{r}
ipfatlas.cells[['RNA']] <- as(ipfatlas.cells[['RNA']],'Assay')
sceasy::convertFormat(ipfatlas.cells, from='seurat',to='anndata', outFile = 'ipfatlas.adata')
```



## load python environment
Weird behavior when reticulate instantiated by other packages, therefore restart R.
```{r}
.rs.restartR()
```
Using the SPAPROS workflow documented by theis lab which is python/scanpy based.
```{python}
import pandas as pd
import scanpy as sc
import spapros as sp
sc.settings.verbosity=0
sc.logging.print_header()
print(f"spapros=={sp.__version__}")
```
Access adata object on the python side. to avoid name conversions throughout python code, just make it "adata." Unpredictable behavior when porting from R to python environment, so store as h5ad and read back in.
```{python}
adata = sc.read_h5ad('ipfatlas.adata')
adata
```
# SPAPROS probe selection
## Preprocess data with scanpy
Filtering has already been done on the Seurat side.
```{python}
sc.pp.normalize_total(adata, target_sum=10000) # 10k target matches default Seurat scale factor
sc.pp.log1p(adata)
sc.pp.highly_variable_genes(adata,flavor="cell_ranger",n_top_genes=1000)
sc.pp.pca(adata, svd_solver='lobpcg') # had issues with arpack
sc.pp.neighbors(adata, n_neighbors=10, n_pcs=30)
sc.tl.umap(adata)
sc.pl.umap(adata, color=['CellType_Category'])
sc.pl.umap(adata, color=['Disease_Identity'])
```
## SPAPROS basic: no constraints.
Asked for 200 genes, because one imagines that various stakeholders will add another 100 for IPF subsets, and probably asthma stakeholders will add another 100 bringing total to 400. Note that this dataset includes normal lung and COPD lung. 
```{python}
selector = sp.se.ProbesetSelector(adata, n=200, celltype_key="Manuscript_Identity", verbosity=0, save_dir=None)
selector.select_probeset()
```
### Export probes for simulations
```{python}
selector.probeset[selector.probeset.selection].to_csv('SPAPROS-basic200.csv')
```

### Quick summary of selected probes
What is the distribution of chosen probes among methods?
```{python}
selector.plot_gene_overlap()
```
I don't understand what the 4th column is, 33 genes that have no attribution for the method of selection? 
```{python}
# list probes
selector.probeset.index[selector.probeset.selection]
```
Table of characteristics for selected probes
```{python}
probe_candidates = selector.probeset[selector.probeset.selection]
probe_candidates
```
### Dotplots of probeset split by selection method
#### Cluster markers (DE 1vs all)
```{python}
probes = probe_candidates[(probe_candidates['celltypes_DE_1vsall']!='')]
probes = probes.sort_values('celltypes_DE')
sc.pl.dotplot(adata, probes.index[0:40], groupby='Manuscript_Identity', dendrogram=False)
sc.pl.dotplot(adata, probes.index[40::], groupby='Manuscript_Identity', dendrogram=False)
```
#### Nuanced cluster markers (celltypes_DE_specific)
```{python}
probes = probe_candidates[(probe_candidates['celltypes_DE_specific']!='')]
probes = probes.sort_values('celltypes_DE')
sc.pl.dotplot(adata, probes.index[0:25], groupby='Manuscript_Identity', dendrogram=False)
sc.pl.dotplot(adata, probes.index[25::], groupby='Manuscript_Identity', dendrogram=False)
```
#### PCA based (celltypes_DE_specific)
```{python}
probes = probe_candidates[(probe_candidates['pca_selected'])]
probes = probes.sort_values('celltypes_DE')
sc.pl.dotplot(adata, probes.index[0:33], groupby='Manuscript_Identity', dendrogram=False)
sc.pl.dotplot(adata, probes.index[33:66], groupby='Manuscript_Identity', dendrogram=False)
sc.pl.dotplot(adata, probes.index[66::], groupby='Manuscript_Identity', dendrogram=False)
```
## SPAPROS with hand-selected genes
We already have some xenium runs where some probesets have reasonable average detection and show up as highly-variable genes in clustering of the Xenium data. Therefore I regard these genes as presumptively high-performance informative genes. Including these in the diversity panel will mitigate the risk of selecting genes whose probesets do not perform well for technical reasons. Therefore ask SPAPROS to include these genes and then modify its other selections accordingly.
```{r}
probesets_xeniumperformance <- read_csv(file='probesets_xeniumperformance.csv')
probesets_xeniumperformance %>% filter(xeniumAvg > 1.35) %>% filter(variance.standardized > 1.20) -> probesets_selected
probesets_selected <- probesets_selected$gene
length(probesets_selected)
```
```{python}
preselected_genes=r.probesets_selected
```
```{python}
# Try to account for selected genes that are in PCA genes.
tmp = sp.se.select_pca_genes(adata, n=adata.n_vars, inplace=False)["selection_ranking"]
n_pca_genes = tmp.loc[~tmp.index.isin(preselected_genes)].sort_values().iloc[:20].max().astype(int)
```
For PCA ranking genes, there are only 2 (S100A8 and AREG) that are in the top 100 PCA genes. So I think we are reasonably safe to just add more PCA genes on top of these.
```{python}
selector = sp.se.ProbesetSelector(adata, n=200, celltype_key="Manuscript_Identity", verbosity=0, save_dir=None, preselected_genes=preselected_genes)
selector.select_probeset()
```

### Export probes for simulations
```{python}
selector.probeset[selector.probeset.selection].to_csv('SPAPROS-200withXeniumCuration.csv')
```

### Quick summary of selected probes
What is the distribution of chosen probes among methods?
```{python}
selector.plot_gene_overlap()
```
```{python}
# list probes
selector.probeset.index[selector.probeset.selection]
```
Table of characteristics for selected probes
```{python}
probe_candidates = selector.probeset[selector.probeset.selection]
probe_candidates
```
### Dotplots of probeset split by selection method
#### Cluster markers (DE 1vs all)
```{python}
probes = probe_candidates[(probe_candidates['celltypes_DE_1vsall']!='')]
probes = probes.sort_values('celltypes_DE')
sc.pl.dotplot(adata, probes.index[0:40], groupby='Manuscript_Identity', dendrogram=False)
sc.pl.dotplot(adata, probes.index[40::], groupby='Manuscript_Identity', dendrogram=False)
```
#### Nuanced cluster markers (celltypes_DE_specific)
```{python}
probes = probe_candidates[(probe_candidates['celltypes_DE_specific']!='')]
probes = probes.sort_values('celltypes_DE')
sc.pl.dotplot(adata, probes.index[0:25], groupby='Manuscript_Identity', dendrogram=False)
sc.pl.dotplot(adata, probes.index[25::], groupby='Manuscript_Identity', dendrogram=False)
```
#### PCA based (celltypes_DE_specific)
```{python}
probes = probe_candidates[(probe_candidates['pca_selected'])]
probes = probes.sort_values('celltypes_DE')
sc.pl.dotplot(adata, probes.index[0:33], groupby='Manuscript_Identity', dendrogram=False)
sc.pl.dotplot(adata, probes.index[33:66], groupby='Manuscript_Identity', dendrogram=False)
sc.pl.dotplot(adata, probes.index[66::], groupby='Manuscript_Identity', dendrogram=False)
```

## SPAPROS with expression penalties
Penalties are 0 to 1, where 0 is bad and 1 is best (i.e., no penalty). Behavior of penalties seems to depend on the the source. If identified by the package, it's a multiplier. If the source is from a manually curated list, all genes with *any* penalty is removed.

We were told by 10x that SCGB1A1 and SFTPC had too high abundance to design probes. COL1A1 is the highest single detected gene in trial runs; I am not aware of any codeword budget issues with COL1A1.

```{python}
sc.pl.violin(adata, ['SCGB1A1', 'SFTPC', 'COL1A1'])
```
```{python}
sc.pl.violin(adata, ['GDF15', 'CLDN4', 'KRT8'])
```
If we wanted to be fairly aggressive, a threshold of like 1 to 6 would get us genes that are like COL1A1 or even more highly expressed. Some high performance genes like KRT8 wouldn't necessarily be selected.
```{python}
# Set thresholds
lower_th = 1.0
upper_th = 6
FACTOR = 0.1

# Calculate quantiles
sp.ut.get_expression_quantile(adata, q=0.99, normalise=False, log1p=False, zeros_to_nan=False)
sp.ut.get_expression_quantile(adata, q=0.9, normalise=False, log1p=False, zeros_to_nan=True)

# Get penalty functions for given factor
penalty_fcts={}
penalty_fcts[f"lower_{FACTOR}"] = sp.ut.plateau_penalty_kernel(var=0.1 * FACTOR, x_min=lower_th, x_max=None)
penalty_fcts[f"upper_{FACTOR}"] = sp.ut.plateau_penalty_kernel(var=0.5*FACTOR, x_min=None, x_max=upper_th)
# Calculate each gene's penalty value
adata.var[f"expr_penalty_lower_{FACTOR}"] = penalty_fcts[f"lower_{FACTOR}"](adata.var['quantile_0.9 expr > 0'])
adata.var[f"expr_penalty_upper_{FACTOR}"] = penalty_fcts[f"upper_{FACTOR}"](adata.var['quantile_0.99'])
# PCA and DE selections with penalties
penalty_keys = [f"expr_penalty_lower_{FACTOR}",f"expr_penalty_upper_{FACTOR}"]

adata.var["expr_penalty_lower"] = adata.var[f"expr_penalty_lower_{FACTOR}"]
adata.var["expr_penalty_upper"] = adata.var[f"expr_penalty_upper_{FACTOR}"]

```
Run the selection. In this run we have not seeded any specific number of genes, curious what it comes up with.
```{python}
# create an instance of the ProbesetSelector class
selector_highexpression = sp.se.ProbesetSelector(
    adata,
    n=None,
    celltype_key="Manuscript_Identity",
    verbosity=1,
    save_dir=None,
    pca_penalties=["expr_penalty_lower", "expr_penalty_upper"],
    DE_penalties=["expr_penalty_lower", "expr_penalty_upper"],
    m_penalties_adata_celltypes=["expr_penalty_lower", "expr_penalty_upper"],
    m_penalties_list_celltypes=["expr_penalty_upper"],
)

```
```{python}
selector_highexpression.select_probeset()
```
### Export probes for simulations
```{python}
selector_highexpression.probeset[selector_highexpression.probeset.selection].to_csv('SPAPROS-highexpression.csv')
```

### Quick summary of selected probes
What is the distribution of chosen probes among methods?
```{python}
selector_highexpression.plot_gene_overlap()
```

```{python}
# list probes
selector_highexpression.probeset.index[selector_highexpression.probeset.selection]
```
Table of characteristics for selected probes
```{python}
probe_candidates = selector_highexpression.probeset[selector_highexpression.probeset.selection]
probe_candidates
```
### Dotplots of probeset split by selection method
#### Cluster markers (DE 1vs all)
```{python}
probes = probe_candidates[(probe_candidates['celltypes_DE_1vsall']!='')]
probes = probes.sort_values('celltypes_DE')
sc.pl.dotplot(adata, probes.index[0:40], groupby='Manuscript_Identity', dendrogram=False)
sc.pl.dotplot(adata, probes.index[40::], groupby='Manuscript_Identity', dendrogram=False)
```
#### Nuanced cluster markers (celltypes_DE_specific)
```{python}
probes = probe_candidates[(probe_candidates['celltypes_DE_specific']!='')]
probes = probes.sort_values('celltypes_DE')
sc.pl.dotplot(adata, probes.index[0:15], groupby='Manuscript_Identity', dendrogram=False)
sc.pl.dotplot(adata, probes.index[15::], groupby='Manuscript_Identity', dendrogram=False)
```
#### PCA based (celltypes_DE_specific)
```{python}
probes = probe_candidates[(probe_candidates['pca_selected'])]
probes = probes.sort_values('celltypes_DE')
sc.pl.dotplot(adata, probes.index[0:33], groupby='Manuscript_Identity', dendrogram=False)
sc.pl.dotplot(adata, probes.index[33:66], groupby='Manuscript_Identity', dendrogram=False)
sc.pl.dotplot(adata, probes.index[66::], groupby='Manuscript_Identity', dendrogram=False)
```
#### Probset cross-correlation
How well are probes correlated with each other?
```{python}

```


# Probeset performance evaluation within SPAPROS
Set up evaluation.
```{python}
# I think there is at least one bug in the code that expects "celltype" as an element.
adata.obs['celltype']=adata.obs['Manuscript_Identity']

# instantiate evaluator
evaluator = sp.ev.ProbesetEvaluator(adata, celltype_key='Manuscript_Identity', metrics={'cluster_similarity','knn_overlap','forest_clfs','marker_corr','gene_corr'}, verbosity=2, results_dir=None)
```

#### Reference: trial lung panel
```{python}
xenium_panel1_genes = pd.read_csv('Xenium_panel_order_08_10_23.csv')['Gene']
```
```{python, eval=F}
evaluator.evaluate_probeset(xenium_panel1_genes, set_id="Xenium Lung Trial")
```
#### SPAPROS basic probeset
```{python, eval=F}
evaluator.evaluate_probeset(selector.probeset.index[selector.probeset.selection], set_id="SPAPROS basic")
```
#### SPAPROS high expression minimal probeset
```{python}
evaluator.evaluate_probeset(selector_highexpression.probeset.index[selector_highexpression.probeset.selection].tolist(), set_id="SPAPROS high expression minimal")
```
```{python}
evaluator.summary_statistics()
evaluator.plot_summary()
```

```{python}
# vignette uses a different method, this is the one in the wrapper functions listing
evaluator.plot_marker_corr()
```

